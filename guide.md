# Subscan EVM Contract Verification Guide (Remix & Standard JSON)

Verifying your smart contract source code increases transparency and trust in your project. This guide outlines how to verify contracts on Subscan (applicable to Darwinia, Moonbeam, Astar, etc.), specifically focusing on how **Remix users** can modify the generated Metadata JSON to meet Subscan's verification requirements.

### üìç Example Context

* **Target Network:** Darwinia
* **Example Contract:** `0x00000000001523057a05d6293c1e5171ee33ee0a`
* **Tool:** [Remix IDE](https://remix.ethereum.org/)

---

### üõ† Phase 1: Preparation in Remix

Before verification, ensure your local compilation environment in Remix matches the settings used during the actual deployment **exactly**.

#### 1. Setup Code & Paths

* Open your project in [Remix](https://remix.ethereum.org/).
* **Attention to Paths:** Ensure your file structure matches the `import` statements.
* *Example:* Upload or edit `Quacks.sol`.



#### 2. Configure Compiler

* Navigate to the **Solidity Compiler** tab.
* **Compiler Version:** Select the exact version used for deployment (e.g., `0.8.x`).
* **EVM Version:** If a specific version was used (e.g., `paris`, `london`), select it; otherwise, leave as `default`.
* **Optimization:** Check `Enable optimization` and set the `Runs` value (commonly **200**). **This must match the deployment settings.**
* Click **Compile Quacks.sol**.

#### 3. Retrieve Metadata JSON

* After successful compilation, go to the **File Explorer** (left sidebar).
* Look inside the `artifacts/` folder (or root directory depending on Remix version).
* Locate the file named: `ContractName_metadata.json` (e.g., `Quacks_metadata.json`).

---

### ‚öôÔ∏è Phase 2: Constructing Standard Input JSON (Crucial Step)

Subscan's "Standard JSON" verification method requires the full source code within the JSON file. However, the default `metadata.json` generated by Remix often contains **URLs (IPFS/Swarm)** instead of the actual source code **content**.

**You must manually edit this JSON file to inject the source code.**

#### 1. Inspect the Generated JSON

Open `Quacks_metadata.json`. In the `sources` section, you might see a structure like this (missing actual code):

```json
"sources": {
  "Quacks.sol": {
    "keccak256": "0x...",
    "urls": ["bzz-raw://...", "dweb:/ipfs/..."] // Subscan cannot read these external links
  }
}

```

#### 2. Modify JSON: Inject Source Code

You need to replace or add to the entry with a `"content"` field containing the actual Solidity source string.

**Example of the Modified JSON Structure:**

```json
{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    // ... other settings
  },
  "sources": {
    // For the main file
    "Quacks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Quacks { ... PASTE FULL SOURCE CODE HERE ... }"
    },
    // For dependencies (e.g., OpenZeppelin) - EVERY imported file needs this
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts...\n... PASTE FULL LIBRARY SOURCE HERE ..."
    }
  }
}

```

> **üí° Tips:**
> * **All** imported files must be listed in `sources`.
> * The value of `"content"` must be a string (watch out for newlines `\n` and escaping quotes).
> * If you are using Hardhat/Foundry, their generated `build-info` files already contain the `content` field, so this manual step is not needed.
>
>

#### 3. Save the File

Save your modified JSON file locally as `Standard-Input.json`.

---

### üöÄ Phase 3: Verify on Subscan

#### 1. Navigate to Contract Page

* Go to the [Darwinia Subscan Contract Page](https://darwinia.subscan.io/verify_contract).

#### 2. Upload Configuration

* **Verification Method:** Select `Standard-JSON-Input`.
* **Compiler Version:** Select the version you used in Remix.
* **Upload File:** Upload the `Standard-Input.json` you created in Phase 2.

#### 3. Submit

Click **Verify**. If the JSON format is correct and the compiled bytecode matches the on-chain bytecode, the verification will succeed.

---

### ‚ùì Troubleshooting

| Issue                  | Possible Cause & Solution                                                                                                                                                        |
|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Bytecode mismatch**  | **Optimization Runs:** Did you use 200 runs in Remix but default in the JSON? Ensure they match.<br>                                                                             |
|                        | **EVM Version:** Ensure the EVM version (e.g., London/Paris) is consistent.                                                                                                      |
| **Parsing Error**      | **JSON Syntax:** Ensure the pasted source code in the JSON doesn't break the JSON string format (escape quotes `"` with `\"`).                                                   |
| **Alternative Method** | If manual JSON editing is too difficult, install the **"Flattener"** plugin in Remix. Flatten your code into one file, and use the **"Flatten Code"** method on Subscan instead. |

### üìö References

* [Solidity Compiler Input/Output JSON Description](https://docs.soliditylang.org/en/v0.5.8/using-the-compiler.html#compiler-input-and-output-json-description)